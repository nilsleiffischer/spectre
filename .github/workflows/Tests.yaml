# Distributed under the MIT License.
# See LICENSE.txt for details.

# Continuous integration tests that pull requests are required to pass. This
# workflow also triggers a version release every month.
name: Tests

# Set any defaults for the runs below.
# - use bash as the default shell since this is almost certainly what
#   is always expected. We use regular expressions in a few places
#   that rely on bash.
defaults:
  run:
    shell: bash

# Note that by default the jobs only run on the base repository, testing pull
# requests and merge commits. Enable GitHub Actions in your fork's repository
# settings to also run the tests on every push to one of your branches.
on:
  # We run all jobs when pull requests are opened, commits are pushed, or pull
  # requests are re-opened after being closed.
  # The jobs triggered by this event run on the base repository of the pull
  # request, so they have access to its caches.
  pull_request:
  # We run those jobs that require no information about a pull request (e.g.
  # unit tests) also on `push` events. This setup tests merge commits into
  # `develop` and also builds up caches on `develop` that can be re-used by PRs.
  # It also runs the jobs on forks if they have GitHub Actions enabled.
  push:
    branches-ignore:
      - gh-pages
  # Once a month we run the tests and release a new version (see the dev guide
  # on "Automatic versioning"). The scheduled workflow always runs on the
  # repository's default branch (`develop`).
  schedule:
    - cron: '0 0 1 * *'
  # Also allow running the workflow manually. This can be used to manually
  # release a version. (see the dev guide on "Automatic versioning")
  workflow_dispatch:
    inputs:
      release_version:
        description: >
          Enter a version name YYYY.MM.DD[.TWEAK] to create a release on success
        required: false
        default: ''

jobs:
  # Make sure no commits are prefixed with `fixup` or similar keywords. See
  # `tools/CheckCommits.sh` for details.
  check_commits:
    name: Commits
    # Only run on pull requests since we don't check _all_ commits, but only
    # those that came after the PR's base ref.
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - name: Check commits
        # `CheckCommits.sh` tests against the local `develop` branch, so that's
        # where we fetch the pull-request's base-branch to. Typically, it is
        # the upstream `sxs-collaboration/spectre/develop` branch.
        run: >
          cd $GITHUB_WORKSPACE

          git remote add upstream
          https://github.com/${{ github.repository }}.git

          git remote -v

          git fetch upstream ${{ github.base_ref }}:develop

          ./tools/CheckCommits.sh

  # - Run simple textual checks over files in the repository, e.g. checking for
  #   a license, line length limits etc. See `tools/CheckFiles.sh` for details.
  # - Run format checker for python to make sure the code is formatted correctly
  # - Check the metadata are consistent
  check_files_and_formatting:
    name: Files and formatting
    runs-on: ubuntu-latest
    container:
      image: sxscollaboration/spectrebuildenv:latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - name: Install Python dependencies
        run: |
          pip3 install \
            GitPython~=3.1.11 \
            PyGithub~=1.53 \
            PyYAML~=5.3.1 \
            tqdm~=4.51.0 \
            uplink~=0.9.2
      - name: Check python formatting
        run: |
          cd $GITHUB_WORKSPACE
          ./tools/CheckPythonFormatting.sh
      - name: Test script
        run: |
          cd $GITHUB_WORKSPACE
          ./tools/CheckFiles.sh --test
      - name: Check files
        run: |
          cd $GITHUB_WORKSPACE
          ./tools/CheckFiles.sh
      - name: Check metadata
        run: |
          python3 tools/CheckMetadata.py
      - name: Check the metadata is consistent with the releases
        run: |
          python3 .github/scripts/Release.py prepare -vv --check-only \
            --zenodo-token ${{ secrets.ZENODO_READONLY_TOKEN }} \
            --zenodo-sandbox \
            --github-token ${{ secrets.GITHUB_TOKEN }}
          python3 .github/scripts/Release.py publish -vv --check-only \
            --zenodo-token ${{ secrets.ZENODO_READONLY_TOKEN }} \
            --zenodo-sandbox \
            --github-token ${{ secrets.GITHUB_TOKEN }}
      - name: Check release notes
        run: |
          python3 tools/CompileReleaseNotes.py -vv \
            --github-token ${{ secrets.GITHUB_TOKEN }}

  # Lint with clang-tidy. We check only code that changed relative to the
  # nearest common ancestor commit with `sxs-collaboration/spectre/develop`.
  clang_tidy:
    name: Clang-tidy
    if: >
      (github.event_name == 'pull_request'
       && github.repository =='sxs-collaboration/spectre'
       && github.base_ref == 'develop')
      || github.ref != 'refs/heads/develop'
    runs-on: ubuntu-latest
    container:
      image: sxscollaboration/spectrebuildenv:latest
    strategy:
      matrix:
        build_type: [Debug, Release]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - name: Fetch sxs-collaboration/spectre/develop
        run: >
          cd $GITHUB_WORKSPACE

          git remote add upstream
          https://github.com/sxs-collaboration/spectre.git

          git remote -v

          git fetch upstream develop
      - name: Configure with cmake
        working-directory: /work
        run: >
          mkdir build && cd build

          cmake
          -D CMAKE_C_COMPILER=clang
          -D CMAKE_CXX_COMPILER=clang++
          -D CMAKE_Fortran_COMPILER=gfortran-8
          -D CHARM_ROOT=/work/charm_6_10_2/multicore-linux-x86_64-clang
          -D CMAKE_BUILD_TYPE=${{ matrix.build_type }}
          -D OVERRIDE_ARCH=x86-64
          -D USE_CCACHE=OFF
          -D DEBUG_SYMBOLS=OFF
          -D BUILD_PYTHON_BINDINGS=ON
          $GITHUB_WORKSPACE
      - name: Check clang-tidy
        working-directory: /work/build
        run: >
          UPSTREAM_HASH=$(
            cd $GITHUB_WORKSPACE && git merge-base HEAD upstream/develop)

          echo "Running clang-tidy relative to: $UPSTREAM_HASH\n"

          make clang-tidy-hash HASH=$UPSTREAM_HASH

  # Release a new version on scheduled or manual events when the tests pass.
  # Only enable this on the `sxs-collaboration/spectre` repository (not on
  # forks).
  release_version:
    name: Release version
    runs-on: ubuntu-latest
    # Run in the container so we can build docs and tests
    container:
      image: sxscollaboration/spectrebuildenv:latest
    if: >
        github.ref == 'refs/heads/develop' &&
        (github.event_name == 'schedule'
          || (github.event_name == 'workflow_dispatch'
            && github.event.inputs.release_version != ''))
    needs:
      - check_files_and_formatting
      # - doc_check
      # - unit_tests
    steps:
      - uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - name: Install Python dependencies
        run: |
          pip3 install \
            GitPython~=3.1.11 \
            PyGithub~=1.53 \
            PyYAML~=5.3.1 \
            tqdm~=4.51.0 \
            uplink~=0.9.2
      # We use the current date as tag name, unless a tag name was specified
      # as input to the `workflow_dispatch` event
      - name: Determine release version
        id: get_version
        run: |
          INPUT_RELEASE_VERSION=${{ github.event.inputs.release_version }}
          RELEASE_VERSION=${INPUT_RELEASE_VERSION:-$(date +'%Y.%m.%d')}
          echo "Release version is: ${RELEASE_VERSION}"
          echo "RELEASE_VERSION=$RELEASE_VERSION" >> $GITHUB_ENV
      - name: Validate release version
        run: |
          VERSION_PATTERN="^([0-9]{4})\.([0-9]{2})\.([0-9]{2})(\.[0-9]+)?$"
          if [[ $RELEASE_VERSION =~ $VERSION_PATTERN ]]; then
            if [ $(date +'%Y') != ${BASH_REMATCH[1]} ] ||
            [ $(date +'%m') != ${BASH_REMATCH[2]} ] ||
            [ $(date +'%d') != ${BASH_REMATCH[3]} ]; then
              TODAY=$(date +'%Y.%m.%d')
              echo "'$RELEASE_VERSION' doesn't match current date '$TODAY'"
            fi
          else
            echo "'$RELEASE_VERSION' doesn't match '$VERSION_PATTERN'"
            exit 1
          fi
          if [ $(git tag -l "v$RELEASE_VERSION") ]; then
            echo "Tag 'v$RELEASE_VERSION' already exists"
            exit 1
          fi
          if [ $(git rev-parse HEAD) == $(git rev-parse origin/release) ]; then
            echo "Nothing changed since last release $(git describe release)."
            exit 1
          fi
        shell: bash
      - name: Reserve Zenodo DOI and prepare repository
        run: |
          python3 .github/scripts/Release.py prepare -vv \
            --version $RELEASE_VERSION \
            --zenodo-token ${{ secrets.ZENODO_READWRITE_TOKEN }} \
            --zenodo-sandbox \
            --github-token ${{ secrets.GITHUB_TOKEN }}
          git diff
      # Push a commit with the new version to the branch we're on (should be
      # `develop` unless the workflow was triggered manually on another branch).
      # The push won't trigger the workflow again because GitHub prevents
      # actions from triggering workflows (this uses the default GITHUB_TOKEN).
      - name: Commit and push
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git commit -a -m "Prepare for release $RELEASE_VERSION"
          git show HEAD
          git status
          git push
          git push origin HEAD:release
      - name: Compile release notes
        run: |
          python3 tools/CompileReleaseNotes.py -v -o release_notes.md \
            --github-token ${{ secrets.GITHUB_TOKEN }}
      - name: Tag and release
        uses: actions/create-release@v1
        env:
          # If we need this event to trigger other workflows we could use a
          # personal access token
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ env.RELEASE_VERSION }}
          release_name: Release ${{ env.RELEASE_VERSION }}
          body_path: release_notes.md
      # The release is now public on GitHub. We build the release documentation
      # from the archive and also build an executable to make sure the archive
      # is functional.
      - name: Build release documentation and an executable
        working-directory: /work
        run: |
          wget https://github.com/${{ github.repository }}/archive/v${RELEASE_VERSION}.tar.gz -O spectre.tar.gz
          tar -xzf spectre.tar.gz && mv spectre-* spectre
          mkdir build && cd build
          cmake \
            -D CMAKE_C_COMPILER=clang \
            -D CMAKE_CXX_COMPILER=clang++ \
            -D CMAKE_Fortran_COMPILER=gfortran-8 \
            -D CHARM_ROOT=/work/charm_6_10_2/multicore-linux-x86_64-clang \
            -D OVERRIDE_ARCH=x86-64 \
            -D CMAKE_BUILD_TYPE=Release \
            -D DEBUG_SYMBOLS=OFF \
            ../spectre
          make doc-check
          make -j2 ExportCoordinates1D
          ctest -R InputFiles.ExportCoordinates.Input1D.yaml.execute
      - name: Deploy to gh-pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          publish_dir: /work/build/docs/html
          cname: spectre-code.org
          publish_branch: gh-pages
          github_token: ${{ secrets.GITHUB_TOKEN }}
          force_orphan: true
      # This action currently doesn't publish the Zenodo record automatically.
      # Instead it prints a link to the website where we can go and hit the
      # "Publish" button when everything looks correct. Once we're convinced the
      # automation works well enough we can add the `--auto-publish` flag to
      # the command below.
      - name: Publish to Zenodo
        run: |
          python3 .github/scripts/Release.py publish -vv \
            --zenodo-token ${{ secrets.ZENODO_PUBLISH_TOKEN }} \
            --zenodo-sandbox \
            --github-token ${{ secrets.GITHUB_TOKEN }}
